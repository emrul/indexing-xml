== xml2 contrib module ==

This module implements the support functions for storing/validating/quering sets of
XML documents above of standard functions presented in core PostgreSQL. This can
be useful in various scenarios, such as heavily changes on XML document or
validations with DTD, XSD, RNG.

== how install this module ==

You must compile it from source code or dowload prepared package and then install
this package to PostgreSQL. Here is brief manual how to do that.

Preconditions:
You have to have compilation machine prepared see http://www.postgresql.org/docs/9.1/static/installation.html
 LibXML 2 header files installed and properly set enviroment variables. I'm
reffering to official http://xmlsoft.org/ site.

1. download it (you can use git repository git://github.com/killteck/indexing-xml.git)
2. configure project with ./configure --with-libxml --with-libxslt
3. change directory to contrib/xml2
4. make # and compile this module
5. sudo make install # will copy module to proper directory and you have to register it
7. CREATE EXTENSION xml2; -- run this query in your SQL interpreter

Succed, you just install new contrib module to PostgreSQL! You can check now
if xml_documents, xml_element_nodes, xml_attribute_nodes, xml_text_nodes tables
are present. If you want to uninstall module, just run DROP EXTENSION xml2;


== functions included in xml2 module ==

Xml2 contrib module include set of functions for XML document handling. We will
briefly describe each.

                                     List of functions
 Schema |           Name           | Result data type |     Argument data types      |  Type
--------+--------------------------+------------------+------------------------------+--------
 public | build_xmlindex           | boolean          | xml, text                    | normal
 public | build_xmlindex           | boolean          | xml, text, boolean           | normal

This 2 functions are used for shredding XML document to prepared tables,

 Schema |        Name         | Type
--------+---------------------+-------
 public | attribute_table     | table
 public | element_table       | table
 public | text_table          | table
 public | xml_documents_table | table

which are created by next function create_xmlindex_tables. Please be sure, that
you don't have tables with same name.

 public | create_xmlindex_tables   | void             |                              | normal

This function create mentioned tables. Tables are created automaticaly after
module installation, so check it before you call this function twice.

 public | dtd_in                   | dtd              | cstring                      | normal
 public | dtd_out                  | cstring          | dtd                          | normal
 public | rng_in                   | rng              | cstring                      | normal
 public | rng_out                  | cstring          | rng                          | normal
 public | xsd_in                   | xsd              | cstring                      | normal
 public | xsd_out                  | cstring          | xsd                          | normal

These functions are I/O for new validation schema data types. Regular user doesn't
need them.

 public | xmlvalidate_dtd          | boolean          | xml, dtd                     | normal
 public | xmlvalidate_dtd          | boolean          | xml, text                    | normal
 public | xmlvalidate_rng          | boolean          | xml, rng                     | normal
 public | xmlvalidate_rng          | boolean          | xml, text                    | normal
 public | xmlvalidate_xsd          | boolean          | xml, xsd                     | normal
 public | xmlvalidate_xsd          | boolean          | xml, text                    | normal

These funcitons do validations for specific validaiton schemas. You can use DTD,
XSD and RNG for validations.

== usage examples ==

If you succed with xml2 module installation, you can use these functions for
XML document handlings. Typical scenario will describe how you can store XML
as shreded type as well as normal text representation. Each of them have own
advantages and disadvantages.

If you shred XML into tables you can do INSERTs, UPDATEs, DELETEs with little
cost and you can use SQL with benefits of INDEXEs. Disadvantage of this approach
is need of XML document reconstruction. So if you want to validate shreded XML
document, you have to deconstruct it and then call validation functions.

SQL example 1: How shred XML document
For shreding you need XML document without any external references, for example
to entity definitions or URI of validation schemas.

--------------------------------------------------------------------------------
SELECT build_xmlindex('<?xml version="1.0" encoding="utf-8"?>
<books>
	<book>
		<author>
			<firstname>Quanzhong</firstname>
			<lastname>Li</lastname>
		</author>
		<title>XML indexing</title>
		<price unit = "USD">120</price>
	</book>
	<book>
		<author>
			<firstname>Bongki</firstname>
			<lastname>Moon</lastname>
		</author>
		<title>javelina javelina</title>
		<price unit = "USD" test = "AM">100</price>
	</book>
</books>', 'bookshelf', true);

first argument is XML document, second is description of it and third idicate if
user want to store original XML document in xml_documents table
--------------------------------------------------------------------------------

SQL example 2: What data are stored in tables
XML document is cut off by nodes and tables xml_documents, xml_element_nodes,
xml_attribute_nodes and xml_text_nodes are filled. For SQL example 1 data looks
like:
--------------------------------------------------------------------------------
SELECT * from xml_element_nodes ;
   name    | did | pre_order | size | depth | parent_id | prev_id | child_id | attr_id
-----------+-----+-----------+------+-------+-----------+---------+----------+---------
 firstname |   1 |         4 |    1 |     3 |         3 |         |          |
 lastname  |   1 |         6 |    1 |     3 |         3 |       4 |          |
 author    |   1 |         3 |    4 |     2 |         2 |         |        6 |
 title     |   1 |         8 |    1 |     2 |         2 |       3 |          |
 price     |   1 |        10 |    2 |     2 |         2 |       8 |          |      11
 book      |   1 |         2 |   10 |     1 |         1 |         |       10 |
 firstname |   1 |        15 |    1 |     3 |        14 |         |          |
 lastname  |   1 |        17 |    1 |     3 |        14 |      15 |          |
 author    |   1 |        14 |    4 |     2 |        13 |         |       17 |
 title     |   1 |        19 |    1 |     2 |        13 |      14 |          |
 price     |   1 |        21 |    3 |     2 |        13 |      19 |          |      23
 book      |   1 |        13 |   11 |     1 |         1 |       2 |       21 |
 books     |   1 |         1 |   23 |     0 |           |         |       13 |
(13 rows)

SELECT * from xml_attribute_nodes ;
 name | did | pre_order | size | depth | parent_id | prev_id | value
------+-----+-----------+------+-------+-----------+---------+-------
 unit |   1 |        11 |    0 |     3 |        10 |         | USD
 unit |   1 |        22 |    0 |     3 |        21 |         | USD
 test |   1 |        23 |    0 |     3 |        21 |      22 | AM
(3 rows)

SELECT * from xml_text_nodes ;
order | depth | parent_id | prev_id
------+-------+-----------+---------
    5 |     4 |         4 |
    7 |     4 |         6 |
    9 |     3 |         8 |
   12 |     3 |        10 |
   16 |     4 |        15 |
   18 |     4 |        17 |
   20 |     3 |        19 |
   24 |     3 |        21 |


--------------------------------------------------------------------------------

\todo show XPath/XQuery to SQL and indexes are used
